/*
 * Copyright (c) Minh Loi.
 *
 * This file is part of Ulangi which is released under GPL v3.0.
 * See LICENSE or go to https://www.gnu.org/licenses/gpl-3.0.txt
 */

import { assertExists } from '@ulangi/assert';
import { SetFormPickerType } from '@ulangi/ulangi-common/enums';
import { computed, observable } from 'mobx';

import { ObservableLanguage } from '../language/ObservableLanguage';
import { ObservableRemoteConfigStore } from '../stores/ObservableRemoteConfigStore';
import { ObservableSetPickerState } from './ObservableSetPickerState';

export class ObservableSetFormState {
  @observable
  public setId: string;

  @observable
  public setName: string;

  @observable
  public learningLanguageCode: null | string;

  @observable
  public translatedToLanguageCode: null | string;

  @observable
  public shouldShowSetNameInput: boolean;

  public readonly pickerState: ObservableSetPickerState;

  @computed
  public get autoGeneratedSetName(): string {
    const learningLanguage = this.learningLanguage;
    const translatedToLanguage = this.translatedToLanguage;

    let setName = learningLanguage ? learningLanguage.fullName : '';
    setName += ' - ';
    setName += translatedToLanguage ? translatedToLanguage.fullName : '';
    return setName;
  }

  @computed
  public get canSelectTranslatedIntoLanguage(): boolean {
    return this.learningLanguageCode !== null;
  }

  @computed
  public get learningLanguage(): null | ObservableLanguage {
    if (this.learningLanguageCode === null) {
      return null;
    } else {
      return this.getLanguageByCode(this.learningLanguageCode);
    }
  }

  @computed
  public get translatedToLanguage(): null | ObservableLanguage {
    if (this.translatedToLanguageCode === null) {
      return null;
    } else {
      return this.getLanguageByCode(this.translatedToLanguageCode);
    }
  }

  @computed
  public get selectedLanguageCodeForCurrentPicker(): null | string {
    if (this.pickerState.currentPicker === SetFormPickerType.LEARN) {
      return this.learningLanguageCode;
    } else if (
      this.pickerState.currentPicker === SetFormPickerType.TRANSLATED_INTO
    ) {
      return this.translatedToLanguageCode;
    } else {
      return null;
    }
  }

  @computed
  public get selectableLanguagesForCurrentPicker(): readonly ObservableLanguage[] {
    if (this.pickerState.currentPicker === SetFormPickerType.LEARN) {
      if (this.translatedToLanguageCode === null) {
        return this.remoteConfigStore.existingRemoteConfig.supportedLanguagePairs
          .filter(
            (pair): boolean =>
              pair.disabled !== true && pair.translatedToLanguageCode === 'any'
          )
          .map((pair): ObservableLanguage => pair.learningLanguage);
      } else {
        return this.remoteConfigStore.existingRemoteConfig.supportedLanguagePairs
          .filter(
            (pair): boolean =>
              pair.disabled !== true &&
              pair.translatedToLanguageCode === this.translatedToLanguageCode
          )
          .sort(
            (pair1, pair2): number => {
              const priority1 =
                typeof pair1.priority !== 'undefined' ? pair1.priority : 999;
              const priority2 =
                typeof pair2.priority !== 'undefined' ? pair2.priority : 999;
              return priority1 - priority2;
            }
          )
          .map((pair): ObservableLanguage => pair.learningLanguage);
      }
    } else if (
      this.pickerState.currentPicker === SetFormPickerType.TRANSLATED_INTO
    ) {
      const learningLanguageCode = assertExists(
        this.learningLanguageCode,
        'learningLanguage must be selected before translateToLanguage.'
      );

      return this.remoteConfigStore.existingRemoteConfig.supportedLanguagePairs
        .filter(
          (pair): boolean =>
            pair.disabled !== true &&
            pair.learningLanguageCode === learningLanguageCode
        )
        .map((pair): ObservableLanguage => pair.translatedToLanguage);
    } else {
      return [];
    }
  }

  private getLanguageByCode(languageCode: string): ObservableLanguage {
    const language = assertExists(
      this.remoteConfigStore.existingRemoteConfig.languages.find(
        (language): boolean => languageCode === language.languageCode
      ),
      'language should not be undefined'
    );
    return language;
  }

  private remoteConfigStore: ObservableRemoteConfigStore;

  public constructor(
    setId: string,
    setName: string,
    learningLanguageCode: null | string,
    translatedToLanguageCode: null | string,
    shouldShowSetNameInput: boolean,
    pickerState: ObservableSetPickerState,
    remoteConfigStore: ObservableRemoteConfigStore
  ) {
    this.setId = setId;
    this.setName = setName;
    this.learningLanguageCode = learningLanguageCode;
    this.translatedToLanguageCode = translatedToLanguageCode;
    this.shouldShowSetNameInput = shouldShowSetNameInput;
    this.pickerState = pickerState;
    this.remoteConfigStore = remoteConfigStore;
  }
}
